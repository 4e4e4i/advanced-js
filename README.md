
# Advanced js

### Что такое 'use strict' и для чего он нужен

Что делает 'use strict'? Это частый вопрос, который мы можем встретить на собеседовании, неплохое начало для разговора.

Это простой вопрос, обычно ожидают, что кандидат на собеседовании знает ответ на него. Но даже если это простой вопрос
вы все еще можете произвести впечатление на интервьюера, показав глубокое понимание значения этого ключевого слова.

Так что же такое strict mode?

Strict mode позволяет вам разместить программу или функцию в так называемый строгий операционный контекст. 
И я собираюсь объяснить что это значит с несколькими примерами, но если в двухсловах, он позволяет легче дебажить код.
Ошибки кода, которые бы в противном случае были проигнорированы или втихую сфейлелись, теперь будут генерировать
ошибки или выбрасывать исключения. Это позволяет вам раньше обнаружить ошибки в коде и быстро направляет вас к источнику
проблемы.

Так первая вещь о которой вы должны сказать - это как включить его. Как включить strict mode в JS файле?

Один из путей, это просто напечатать строку 'use strict' и поместить ее в самом вверху файла. Если вас попросят на интервью
записать его, помните никогда не пишите как use strict. Это не специальное ключевое словое use и не специальное ключевое
слово strict. Это строка. И вы можете спросить, почему это строка? Это выглядит довольно странно. И ответ по-настоящему
очевидно прост. Когда эта функция была впервые разработана и реализована, старые браузеры не поддерживали ее, 
только новые браузеры поддерживали ее. 
Если бы решили использовать ключевое слово «use» и ключевое слово «strict» при загрузке этого файла в более 
старом браузере, браузер, который бы не знал об «use strict», выдал бы ошибку. И поэтому то что они сделали, они просто
положили его в строку и так старые браузеры читали этот файл, говорили "воу да это же строка в вверху файла, они ничего не делает
и поэтому я просто проигнорирую ее". А в новых браузерах, если он увидит строку 'use strict' они поймут, что необходимо
переключится в strict mode operating context.

Это один из путей, в котором можно сказать JS, чтобы он смотрел на код в strict mode. И используя данный подход,
strict mode будет применяться ко всему коду по всему файлу, но есть и другой способ.

```javascript
// Not strict mode... 
function newCode() {
  "use strict"
  // Strict mode...
}
// Not Strict mode...
```
Если вы возможно когда-либо работали с легаси JS кодом, очень-очень старым JS кодом. Я серьезно сомневаюсь, что вы
на самом деле окажетесь в данной ситуации, потому что 'use strict' существует уже очень давно. Но если у вас есть
полное знание, это действительно возможно применить 'strict mode' только к части кода, с помощью добавления 'use strict' 
в верхнюю часть блока функции, затем все что будет под данной строкой, будет читаться в strict mode, а все что снаружи блока
функции будет в non-strict mode. 

Я показал, как включать его. А какого назначение 'use strict' мода? Что он на самом деле делает?

Одна из первых вещей это, что в 'use strict' моде использование переменной перед тем как она была определена вызовет ошибку.

Например, без strict mode назначение значения недекларированной переменной возможно и будет автоматически создана глобальная
переменная с таким именем. В JS всегда есть глобальный объект и в нем находятся все глобальные переменные и 
глобальные функции. В браузере глобальный объект - 'window'. Но если вы используете его внутри node, глобальный объект
будет называться 'global'.

Поэтому с помощью декларирования asim = 1; мы создаем глобальную переменую, глобальное свойство на глобальной переменной
window, с названием asim и мы назначаем ей значение 1.

```javascript
asim = 1;
console.log(window.asim); // 1
```

Так мы разобрались как это работет...Так почему это плохая вещь? Почему это раздражает? Позвольте мне показать специфичный
пример, когда это может быть невероятно разочаровывающим. Давайте представим, что в моем приложением, я декларировал переменную
под названием theVal. Я декларировал ее должным образом, используя theVal в самом начале моего файла и назначил ей
значение 0. И затем, где-то в приложение я решил изменить значение моей theVal переменной в 1, но я сделал глупую ошибку -
вместо того, чтобы напечать theVal, я написал thVal. И наконец я использую переменную theVal в 'if' операторе, думая будто
я установил значение в 1 и, ожидая что выведет Hello. Но, к сожалению, Hello не будет выведено в консоле, потому что была совершена ошибка
в названии переменной.

```javascript
var theVal = 0;
//
thVal = 1;
//
if (theVal > 0) {
    console.log("Hello")
}
```
  
А теперь если мы используем 'use strict'. Вызов недекларированной переменной вызывает ошибку.

```javascript
"use strict";

var theVal = 0;
//
thVal = 1; // вызывает ошибку: thVal is not defined
//
if (theVal > 0) {
    console.log("Hello")
}
```

Другая фича "use strict" - то что она останавливает вас от использования слов, которые уже зарезервированны для
будущих версий JS. Давайте например создадим переменную let и назначим ей значение - 1. Затем перезагрузим страницу и все
будет впорядке. 

```javascript
var let = 1;
```

Но если я добавлю "use strict" на вверх файла, вы увидете ошибку вызванную данной переменной

```javascript
"use strict"

var let = 1; // Вызовет ошибку: Unexpected strict mode reserved word
```
Причина данной ошибки, что слово let уже зарезервированно для будущих версий JS. По факту уже используется
в ECMA script 6 версии JS

Еще одна фича 'use strict' - вы не можете удалять функции, переменные или аргументы функций.

Давайте посмотрим на примере без использования use strict. Если вы всего-лишь напечатаете var foo = 0 и затем
попытаетесь удалить foo, перезагрузите страницу, не возникнет никакой ошибки...Тоже самое с функциями

```javascript
var foo = 1;
delete foo;

function moo() {}
delete moo;
```

А если вы будете использовать 'use strict' mode, то при удалении будет вызвана ошибка

```javascript
"use strict"

var foo = 1;
delete foo; // Delete of an unqualified identifier in strict mode

function moo() {}
delete moo; // Delete of an unqualified identifier in strict mode
```

И следующая вещь, о которой я хотел бы рассказать - это ключевое слово eval и use strict mode.
Strict mode делает eval немного безопаснее.

Например в non-use strict mode вы можете делать вещи, такие как var eval = 1; или именовать так функции, и никакой ошибки
не будет вызвано.

А в use strict mode будет вызвана ошибка

```javascript
"use strict"

var eval = 1; // Unexpected eval or arguments in strict mode
```
Если вы знаете eval, он позволяет вам оценивать выражения JavaScript, просто передавая строку. Таким образом,
он позволяет вам выполнять только произвольные биты типа кода JavaScript в 'var a = 1'.

```javascript
eval('var a = 1');
console.log(a); // 1
```
Этот код выполняет 'var a = 1', но в non-use strict mode переменная A вытекает из выражений eval, поэтому, если
вызвать console.log (a); вы можете видеть, что он выводит значение переменной A, которая фактически создается или 
определяется в блоке eval. Таким образом, вы можете представить себе ситуации, в которых это может вызвать проблемы с 
безопасностью или просто загрязнить ваше собственное пространство имен.

Но если мы используем use strict mode, любые переменные, что вы определите внутри eval существуют только внутри eval и
не вытекают наружу.

```javascript
'use strict'

var a = 2;
eval('var a = 1');
console.log(a); // 2
```

### Javascript передает переменные по ссылке или по значению?

Вопрос заключается в том, что когда вы передаете перменную A в функцию foo как параметр, вы передаете по значению переменной
или по ссылке? 

Быстрый ответ на этот вопрос заключается в том, что передаваемые примитивные типы, такие как: строки, числа, булин переменные,
передаются по значению, а объекты передаются по ссылке. И прекрасно, это по правде правильный ответ, но если вы дали
мне такой ответ мгновенно, я бы задал сразу следующий вопрос, который был бы что-то вроде "Объясни мне что означает pass-by value
и pass-by reference". Потому что я хочу знать что ты не только просто запомнил этот ответ, но и глубоко понимаешь, как это
происходит.

#### Позвольте объяснить для начала что значит pass-by value.

Так что же означает то, что если вы изменяете значение примитивного типа внутри функции, изменения не будут влиять на переменную
во внешней области видимости.

```javascript
'use strict'

var a;
function foo(a) {
    
}
```

В данном примере переменная A находятся во внешней области видимости, а внутри фукнции находится область видимости функции
или внутренняя область видимости. Так если var a = 1; 1 - примитивный тип и я сделаю console.log(a) во внешней области видимости
и также я вызову функцию foo с переменной a, внутри которой я измению переменную на значение 2, то консоль лог все равно
выведет 1. И это потому примитивные типы, когда они передаются в функцию, они передаются по значению. Образ мышления о том, что
на самом деле означает pass-by value, есть по-настоящему передача копии переменной A. Поэтому все что вы делаете с переменной
внутри тела функции не будет никак влиять на переменную A во внешней области видимости.

```javascript
'use strict'

var a = 1;
function foo(a) {
    a = 2;
}
foo(a);
console.log(a); // 1
```

#### Что же такое pass-by reference? 

Когда вы передаете что-то по ссылке, вы передаете что-то указывающее на что-то еще. Так с передачей JavaScript объект
передает его по ссылке, когда изменяете свойство этого объекта изнутри функции, изменения будут отражены во внешней
области видимости. Когда вы передаете объект в функцию, вы передаете не ссылку объекта, вы передаете что-то указывающее на 
А объект.

```javascript
'use strict'

var a = {};
function foo(a) {
  a.moo = false;
}
foo(a);
console.log(a); // Object {moo: false}
```

Позвольте мне изменить код немного. Внутри функции вместо изменения свойства A, я буду изменять именно то на что указывает
A переменная. И если мы перезагрузим страницу, то увидим, что переменная А не изменилась. В JavaScript когда мы говорим, что
мы передаем по ссылке (pass-by reference), мы не можем изменять то на что указывает A, поэтому если вы передаете в A, это не
изменит то на что оно указывает. Мы можем только изменять свойства А во что-то другое или добавлять свойства. Мы не можем
изменять то на что указывает А.

```javascript
'use strict'

var a = {'moo': 'too'};
function foo(a) {
  a = {'too': 'moo'};
}
foo(a);
console.log(a); // Object {moo: 'too'}
```


## Types Equality

### Какие типы бывают в Javascript?

Сейчас в ECMAscript 5 спецификация определяет 6 различных типов в JS. У нас есть 5 примитивных типов и один непримитивный
тип. 

```javascript
"use strict";

Boolean // true, false
Number  // 1, 1.0
String // "a", 'a'
Null  // null
Undefined // undefined

Object  // {} , new Object()
```

Со стороны примитивных типов у нас есть boolean, number, string, null, undefined и непримитинвый тип - объект.

Так мы можем использовать функцию в JS, называемую **typeof**, способную выводить тип значения, которую мы в нее передадим.

```javascript
typeof(1) // "number"
typeof('a') // "string"
typeof('true') // "boolean"
typeof('undefined') // "undefined"
typeof('null') // "object"
typeof({}) // "object"
```

Проблема возникает, когда мы получаем тип примитива Null, потому что функция, возвращает нам, что это объект, хотя
null - null. И этот баг известен уже очень давно, к сожалению его пофиксить в данный момент невозможно, так как это
вызовет ряд проблем.

На самом деле вопрос простой, но можно задать посложнее, например:

Какая разница между динамически типизированным языком как JavaScript и статически типизированным языком, таким как Java?

Представьте, что мы пишем Java код. Поэтому если мы пишем Java, мы можем определить строку так:

```java
String a = 'moo';
```

И так должна создаться переменная называемая А и в статически типизированном языке, как Java, мы говорим Java, что эта
A будет содержать строки и только строки. И затем мы говорим Java что переменная А будет содержать строку moo. Так
в статически типизированном языке как Java перед тем как код запустится, пока вы пишите код, вы должны указать, какие
именно типы каждая переменная должна содержать. Если позже вы попытаетесь сделать что-то подобное

```java
String a = 'moo';
a = 1; // Вызовет ошибку
```

Потому что Java знает, данная переменная может содержать только строки и вы пытаетесь заставить переменную содержать число.

Когда как в JavaScript мы можем сделать что-то подобное:

```javascript
var a = 'moo';
```

В JS у нас есть переменная под названием А, но тип переменной А на самом деле определяется тем значением, которое мы
присвоили А. Если мы используем функцию typeof(a), то получим результат "string". Но позже мы можем изменить переменную
А и указать,  что она равна числу 1 и теперь typeof будет показывать нам "number"

```javascript
var a = 'moo';
typeof(a); // string
a = 1;
typeof(a); // number
```

Это и означает динамически типизированный язык. С JavaScript тип переменных определяется динамически в ран тайме, когда мы
действительно запускаем приложение. В то время как в Java typeof переменной определяется статично, в то время когда мы пишем
код для нашего приложения.

В чем преимущество одного над другим? Я бы сказал, что нам самом деле нет чистого преимущества одного над другим.
Они оба полезные в разных сценариях и в различных ситуациях. С динамически типизированным языком вы проще заходите и погружаетесь,
низкий порог вхождения. Он намного легче в написании быстрых JS приложений или быстрых Python приложений. Но вы сможете
обнаружить ошибки только в ран тайме. В тот момент, когда приложение реально запущено. Если, возможно, в нашей логике
приложения некоторая функция ожидала, что А будет строкой, но мы каким-то образом изменили ее на число в какой-то момент
выполнения, мы обнаружим это только тогда, когда запустим приложение и возможно оно выдаст ошибку или даже хуже, возможно
ошибке в самой программе и затем приложение продолжит молча вести к большим и к худшим ошибкам, ведущим к еще большим
ошибкам. 

В то время как в статически типизированном языке, как Java, когда мы компилируем приложение, компилятор сам бросит ошибку, если мы
создадим переменную, содержащую неверный тип. ТАк мы можем раскрыть проблемы очень очень рано в нашем цикле разработки.
Это происходит за счет времени создания наших приложений и немного сложнее написание.

Есть и другие преимущества использовать статически типизированный язык. Некоторые проблемы, связанные с управлением памятью
и производительностью, могут более жестко контролироваться статически типизированными языками по сравнению с динамически
типизированными языками. 

Другой последующий вопрос, который я могу задать. 
Вы могли бы заметить, что в наших примитивных типах, смешанных между собой, у нас есть два типа, которые, возможно,
действительно означают одно и то же. У нас есть null, и у нас есть undefined. 
У нас есть два, казалось бы, избыточных способа представить эту концепцию бесполезной, но на самом деле между ними 
есть небольшая разница.

Так, если я объявлю переменную А в нашем приложении и вызову console.log(a)

```javascript
var a;
console.log(a); // undefined
```

Вы можете видеть, что я на самом деле не назначил значения для этой переменной и поэтому приложение не знает какого типа
А, коносоль лог выведет undefined. Потому что это то, что JavaScript устанавливает для переменной А, когда он не знает тип
переменной, когда переменная не была инициализированная с другим значением. Так undefined используется JavaScript и
означает отсутствие значения. Он используется для неинициализированных переменных, поэтому такие переменные, как А, не 
были инициализированы другим значением. Он используется для пропуска параметров в функциях, и он используется для 
неизвестных переменных и свойств для таких вещей, как объект window.

Поэтому если мы сделаем window.hello и это несуществуемое свойство в объекте window, то вернется undefined. 

Так для меня undefined - это основная функция JavaScript, она используется движком JavaScript, чтобы сообщить вам, что
это либо неинициализировнная переменная, либо параметр, осутствующий в списке параметров функции, либо, возможно,
неизвестное свойство объекта.

В то время как, если бы мы напечатали var a = null;

```javascript
var a = null;
console.log(a); // null
```

То консоль вывело бы как очевидно null. Но я бы сказал, что null используется программистами для обозначения отстутствия 
значения. Но JavaScript движок никогда не установит значение в null для вас, он всегда будет устанавливать undefined, если
он не значет что это. Только программисты устанавливают переменную в null. Я думаю, что это тонкое, но важное различие
между undefined и null.

Другой интересный факт относительно null и undefined, который я думаю представляет интерес, пришедший из другого
статически типизированного языка. В языке, например, Java, если мы написали String a = null, и я знаю, что это недопустимый
код в JavaScript, но здесь мы говорим, что есть переменная с именем А, и это строковая переменная и значение этой переменной
в том, что мы еще не знаем, что это такое, поэтому я хочу сказать, что это null. В статически типизированных языках 
null - это не само значение, а концепция отсутствия значение, тогда как в JavaScript Null - значение. И мы знаем, что
null - значение, потому что мы можем написать typeof null и он будет иметь тип - object(null). TypeOf Null имеет значение
null, а тип Null имеет одно значение и только одно значение, которое является строкой, которая является ключевым словом null.

Тоже самое касается undefined.

### Какая разница между == и ===

Первый вариант - двойное равенство, которое называется равенством. Тройное равенство - строгое равенство в JavaScript.

Если вкратце, то тройное равенство проверяет как и тип, так и равенство значений, тогда как двойное равенство проверяет
равенство только значений слева от оператора и справа. Лучший способ объяснить и понять различия между равенством и 
строгим равенством это только черзе ряд примеров.

Например если мы будем писать в консоли:

```javascript
0 === 0; // true
0 !== 1; // true
0 == 0; // true
0 != 1; // true
```

Все это очень очевидно, а вот если мы начнем использовать другие значения:

```javascript
'' == '0' // false
0 == ''  // true
0 == '0'  // true

0 === '' // false
0 === '0' // false
```

Во время двойного сравнения JavaScript пытается разумно найти способ преобразования обоих значений, чтобы они были одного
типа. Поэтому в примере 0 == '0', JS пытается конвертировать число с левой стороны в строку, потому что он обнаруживает
строку с правой стороны и мы видем, что JS делает используя функцию String и передает в нее параметр 0

```javascript
String(0) == '0' // вот что на самом деле происходит при сравнении числа и строки
```

В JavaScript это называется Приведение типа (type coercion) и когда вы используете оператор двойного сравнения или
оператор нестрого равенства, это то, что JS пытается сделать, он пытается разумно привести оба значения к одному типу.

Это может привести программисто в затруднительное положение, например, давайте я перезагружу страницу и если я сделаю
false == 'false' это будет false.

```javascript
false == 'false'; // false
```

Из-за того что JS пытается конвертировать булин false в строку. 

```javascript
String(false); // 'false'
```

Но тогда почему же мы имеем false, если 'false' == 'false'? Причина что false == 'false' возвращает false в том, что 
JS пытается конвертировать boolean false в строку, а пытается конвертировать строку в boolean. 

```javascript
Boolean('false'); // true
```

Если значение на какой-либо стороне оператора равенства другого типа JS пытается привести к одинаковому типу значения.
И правила по которым JS пытается делать это очень сложные и сложно запоминаемые.
 
https://dorey.github.io/JavaScript-Equality-Table/
 
Поэтому я только покажу вам данную таблицу, в которой видно странные поведения при строгом равенстве против обычного равенства. Так в строгом равенстве, когда 
сравнивают true с true получают результат true. И любые другие варианты вернут false. И вы можете знать заранее что произойдет
когда вы сравнивает одно значение с другим. Когда вы начинаете использовать оператор нестрогое равенство то то, что возвращается
будет для вас очень неожиданным, поэтому лучше всегда использовать строгое равенство. 

### Что такое NaN и как мы проверяем его?

Какого типа NaN? NaN в JS расшифровывается как not a number, и если мы заглянем в консоль, то увидим, что у нас есть свойство
значения NaN

```javascript
NaN // NaN
```

а typeof(NaN) будет как не странно - number
```javascript
typeof(NaN); // number
```

Хоть это и означает not a number. И он используется чтобы определять числа, которые не являются настоящими числами, возможно
результат какого-нибудь неправильного расчета. Например, ели мы попробуем сделать 'abc'/4 , это выведет NaN.

```javascript
"abc"/4 // NaN
```

И это можем показать довольно простым. Но есть несколько по-настоящему удивительных характеристик у NaN, которые могут оберунтся
в ужасные баги, если вы не ознакомлены с ними. 

Первая вещь, которую люди находят очень запутанной в отношении NaN, и это на самом деле является официальной спецификацией
для JavaScript, заключается в том, что NaN сравнивают с чем-либо еще в мире, поэтому, если NaN равен false,
это нормально, NaN равняется false - false.

```javascript
NaN == 1 // false
NaN == false // false
```

Если сравнивать NaN с любым значением всегда будет false, но самое путающее, что если NaN сравнить с самим собой, это так же
будет false!! 

```javascript
NaN == NaN // false
```

Как же на самом деле проверяется является ли значение NaN? Вы не можете сравнить NaN с NaN. К сожалению есть метод, но 
у него есть свои проблемы. Существует встроенная функция в JavaScript - isNaN. Так если вы передадите в isNaN(NaN) вернется
true. Это один путь как мы можем проверять на NaN. Но у данной функции есть свои проблемы, например, если передадим в нее
число 1, то получим false и это нормально, но если мы передадим в нее строку "1", то это снова будет false. Но если вы
передадите строку "А" то вернется true

```javascript
isNaN(1) // false
isNaN("1") // false
isNaN("A") // true
```

То что здесь произошло, как мы и проходили ранее, это неявное принуждение (implicit coercion). Так в isNaN функции 
параметр, которые передается в нее приводится к типу. JS пытается привести A в число, чтобы проверить на NaN. Поэтому
когда он пытается привести А в число, Number("A") - NaN. Поэтому isNaN(Number("A")) - true.

Но есть небольшой трюк в JS. 
Таким образом, единственный способ полностью проверить, является ли переменная isNaN, так как NaN - это единственное
значение JavaScript, которое обрабатывается неравномерно для себя, вы всегда можете проверить, является ли значение 
isNaN, проверив равенство для себя, используя оператор !==. Так когда мы используем оператор !==, например, 

```javascript
var a = NaN;

a !== a; // true

a = 1;

a !== a; // false

a = 'a'
a !== a; // false
```

Если А равно NaN из-за странного свойства NaN, где оно не равно себе. Так как это единственный тип, который при равенстве 
самого с собой выдает false можно использовать данные трюк, чтобы определить является NaN значение или нет.

### Какие различия в областях видимости в JavaScript?

Под областью видимости мы имеем ввиду продолжительность жизни переменной, т.е. где эта переменная видна и доступна для
вас чтобы использовать ее в коде.

В JavaScript мы имеем не так много, но несколько различных типов областей видимости. 

Любые переменные объявленные вне функций, например, я объявил переменную и назвал ее asim, которая находится в глобальной
области видимости. Такие переменные называются глобальными переменными и они доступны в любой части вашего приложения, включая
глубоко вложенные, внутри кучу других функуций, вы все еще будете иметь доступ к таким переменным, до тех пор пока они не
будут переопределены в других областях видимости.

```javascript
var asim = 1;
``` 

Другой способ определить глобальную переменную - добавить ее как свойство в глобальный объект. И так как мы находимся в
браузере, то глобальный объект - window.

```javascript
window.moo = 1;
console.log(moo);
```

И так мы можем определить нашу новую глобальную переменную через новое свойство глобальное объекта.

Причина по которой мы можем использовать moo как глобальную переменную, таким же образом как мы можем использовать asim 
как глобальную переменную - это то что все глобальные переменные на самом деле являются свойсвами объекта window.
Поэтому если я напишу window.asim - получу значение нашей глобальной переменной asim.  

Этот объект window доступен только в браузерах, если вы кодите JavaScript внутри node, то глобальный объект уже будет - global.

И так у нас есть переменные в глобальной области видимости. Другая область видимости, которая есть в JavaScript - область видимости функции
или локальная область видимости переменных.

Так если внутри нашей функции moo я объявлю переменную foo и задам ей значение 1, и затем использую эту переменную снаружи
функции moo, то получу ошибку что данная переменная не определена.

```javascript
function moo() {
 var foo = 1;    
}
console.log(foo) // ReferenceError: foo is not defined
```

Все из-за того что область видимости переменной foo находится и доступная только изнутри области видимости, изнутри
блока этой функции, в которой она была определена.  

Если мы попытаемся вывести переменную внутри функции то все будет хорошо

```javascript
function moo() {
    var foo = 1;
    console.log(foo)
}

moo(); // 1
```

Если вы пришли из других языков, таких как Java или даже Python, или С++, вы можете подумать что JavaScript имеет что-то
подбное области видимости уровня блока (block level scope). Например:

```javascript
for (var i=0; i< 5; i++) {
    var j = 5;
}
```

В других языка переменная J и возможно переменная I будут видны только внутри блока цикла. Снариж этого блока переменные
будут не видно, но по факту в JavaScript если мы попытаемся вызвать снаружи цикла переменную J, выведется значение 5.

```javascript
for (var i=0; i< 5; i++) {
    var j = 5;
}

console.log(j); // 5
```

Это потому что JavaScript не имеет такого концепта, как область видимости уровня блока. Переменные внутри цикла будут
доступны снуржи блока области видимости, в которой они были объявлены.  И потому что этот цикл for в глобальной области видимости
все что мы делаем в нем происходит в глобальной области видимости. 

Так есть только 2 места, 2 области видимости в которых ваши переменные могут существовать - function scope или global scope.

### Что такое всплытие переменных

Чтобы описать всплытие переменных, я собираюсь показать вам пример:

```javascript
"use strict";

console.log(a); // undefined
var a = 1;
```

Мы используем use strict, и из-за того что мы используем use strict, это означает, что переменная должна быть объявлена
до того как она будет использована. Поэтому данный код должен вызвать ошибку, или я это должен ожидать. Но если мы испытаем
данный код то увидим, что ошибки не последует и нам выведется undefined.

И если бы я не понимал всплытие переменных это было бы очень запутано. Но чтобы понять что на самом деле происходит нам
нужно понять что происходит у JavaScript под капотом. 

Когда JavaScript видит код как например var a = 1; он разбивает это на две строки. Первая часть будет объявление var A и 
она будет прикреплена на самом вверху страницы, и затем просто приравнивает a = 1, по типу такого:

```javascript
"use strict";
var a;

console.log(a); // undefined
a = 1;
```

Поэтому когда мы делаем console.log(a), данная переменная уже объявлена и выводится undefined, т.к. значение не было задано.

Так JavaScript автоматически поднимаем объявление переменной на самый вверх охватывающей области видимости.

Наряду с переменными JS так же будет поднимать и сами функции. Давайте посмотрим на другой пример:

```javascript
"use strict";

foo();
function foo() {
    console.log(a); // undefined
    var a = 1;
}
```

Мы вызываем функцию foo, но вызываем ее перед тем как объявили или определили что такое foo. Так что же вы ожидаете при
вызове таким образом функции?

Снова нам выводится обычный console.log(a). Потому что JavaScript способен вызывать функцию foo даже перед тем как увидит 
саму функцию foo, из-за того что происходит всплытие (подъем функции).  Когда он увидит код объявления функции, он переместит
на самую верхнюю часть какую сможет найти.

То есть произойдет нечто такое: 

```javascript
"use strict";

function foo() {
    console.log(a); // undefined
    var a = 1;
}
foo();
```

А что произойдет если мы объявим вместо функции foo переменную foo равную анонимной функции?

```javascript
"use strict";

foo(); // TypeError: foo is not a function

var foo = function() {
    var a;
    console.log(a);
    a = 1;
}
```

Мы можем быть немного запутаны, потмоу что мы думали что со всплытием это должно было перенестись на вверх области, но здесь
происходит тоже самое что и со всплытием переменных, JavaScript разобъет код на две строки и перенес наверх объявление переменной
foo, а ее значение оставит снизу, поэтому при вызове переменной без значения, которая будет равнятся undefined произойдет ошибка.  

### Что такое цепь области видимости (scope chain)?

До этого мы разговаривали о различиях между областями видимости в JavaScript. Я упоминал о глобальной области видимости и
так же о области видимости функции. Важный факт о области видимости функции - это то что они могут вкладываться в другие
области видимости функций. И когда внутренней функции нужно использовать переменную, она ищет вверху и это называется цепью области видимости.

Сначала она ищет переменные внутри собственной области видимости функции, затем, если она не может найти их, то начинает
искать во внешней области видимости функции, и если не находит там, то уже ищет до тех пох во внешних областях, пока не дойдет до
глобальной области видимости.

Вы можете подумать, что это все так просто и вы  легко понимаете данный концепт. Но есть один очень важный факт, который
нужно знать.

Цепь областей видимости определяется тем, как программа записывается в файл. Так что лучший способ объяснить это с помощь
пары примеров:

```javascript
"use strict";

function foo() {
    console.log(myvar); // Uncaught ReferenceError: myvar is not defined
}

function goo() {
    var myvar = 1;
    foo();
}

goo();
```

У нас есть функция foo, внутри которой мы хотим вывести в консоль переменную myvar Затем есть функция goo внутри которой
мы объявляем переменную myvar и задаем ей значение 1 и вызываем внутри функцию foo. После этих функций мы вызваем в глобальной
области видимости функцию goo.

И если мы запустим данный код, то получим ошибку Uncaught ReferenceError: myvar is not defined

Причина этому, что цепь областей видимости определяется Лексически и это слово значит, что цепь областей видимости определяется
в порядке, в котором код написан на странице или файле.

Так переменная myvar не доступна в foo функции потому что лексически переменная не была объявлена над функцией foo.

Чтобы объяснить это проще, давайте поменяем кое что в коде:

```javascript
"use strict";

function goo() {
    var myvar = 1;
    function foo() {
        console.log(myvar); 1
    }
    foo();
}

goo();
```

Теперь консоль лог возвращает единицу, потому что цепь областей видимости лексически определена, поэтому когда внутри функции
foo вызывается коносоль лог, он ищет переменную myvar, сначала в своей области видимости, а затем во внешнюю область видимости,
которая у нас является goo функция и здесь он находит, данную переменную. 

Подведем итог, цепь областей видимости определяется в том порядке, в котором код написан на странице или файле, то есть 
начиная оттуда, где мы объявляем функциюю, а не где ее вызываем.

### Что такое IIFE

IIFE - расшифровывается как Immediately Invoked Function Expression

Для того чтобы понять почему мы можем использовать ее, рассмотрим пример:

В этом примере у нас будут два файла main.js и other.js:

main.js
```javascript
"use strict";

var thing = {'hello': 'main'};
console.log('main: ', thing);
```
other.js
```javascript
"use strict";

var thing = {'hello': 'other'};
console.log('other: ', thing);
```

И в index.html мы подключаем оба этих файла

```html
<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
             <meta charset="UTF-8">
             <title>Document</title>
             <script src="main.js"></script>
             <script src="other.js"></script>
</head>
<body>
  
</body>
</html>
```

И когда запустим index.html мы увидим что в консоль логе у нас выводится оба наших объекта по порядку, в котором они
были подключены в html

Вопрос будет заключатся в том, так как мы использовали две глобальные переменные, первая - thing в main.js и  вторая с точно
таким же название в other.js. И какая же остается у нас в самом конце? Если мы напишем в консоле thing, то увидим, что
переменная была перезаписана последним объявление в other.js. 

Как мы сможем решить данную проблему? 

До этого мы изучили разницу в областях видимости. У нас есть глобальная область видимости, которую мы видим здесь, когда
объявляем переменные прямо в глобальной области. Так же у нас есть область видимости функции и все что мы объявляем в 
в ее области, существует только внутри блока функции. Поэтому с помощью этой информации мы можем решить нашу проблему.

Если в other.js мы напишем функцию otherScope и поместим в нее наш код. И затем вызовем эту функции, код внутри функции
будет находится в области видимости функции и не будет влиять на глобальные переменные.

other.js
```javascript
function otherScope() {
    "use strict";
    
    var thing = {'hello': 'other'};
    console.log('other: ', thing);
}
otherScope();
```

Но такой код выглядит слишком громоздким и долго печатемым для разработчиков. И на самом деле есть более сжатый и 
лаконичный способ реализации этого. Вместо того чтобы использовать именованную функцию, мы можем использовать анонимную и
если мы обернем ее в скобки, то сделаем ее вызываемой и затем сможем вызвать ее с помощью () - это и называется IIFE

```javascript
(function() {
    "use strict";
    
    var thing = {'hello': 'other'};
    console.log('other: ', thing);
})();
```








